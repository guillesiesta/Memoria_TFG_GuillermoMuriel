\chapter{Análisis}
En este capítulo se aborda la fase de análisis de los distintos requerimientos  del sistema para cumplir con los objetivos del proyecto. Tanto los acertijos, las soluciones propuestas a ellos y la puntuación de cada solución son datos que son introducidos por los usuarios. El sistema tiene que ser capaz de poder permitir esa interacción de una manera sencilla e intuitiva.

En primer lugar se abordarán las cuestiones relativas al funcionamiento de la aplicación y, a partir de ahí se definirá la arquitectura mediante la cual la aplicación podrá desarrollarse.

Una vez definida la arquitectura hará una búsqueda exhaustiva de las distintas tecnologías existentes que ayuden a cumplir los requisitos específicos de cada módulo que la forma y, la elección de la adecuada para el desarrollo de la aplicación.

Por último, abordaremos el despliegue de la aplicación. Una vez más, se procederá a hacer una búsqueda exhaustiva de las distintas tecnologías que permitirán el despliegue en la nube de cada uno de nuestros módulos diferenciados. Una vez estén definidas, se procederá a la elección de aquella alternativa que nos solucione y complete nuestros requisitos.

\section{Requisitos de la aplicación}

La aplicación se presentará al usuario como una web actual en la que habrá que introducir usuario y contraseña para acceder. 

Desde el punto de vista del usuario, una vez dentro de la aplicación, se presentarán todos los acertijos del sistema, pues el objetivo principal es que el usuario comience a interactuar. Por ello, es fundamental que en cualquier momento el usuario pueda:

\begin{itemize}
    \item Proponer un acertijo para compartir con los demás usuarios
    \item Acceder a sus acertijos para consultar su estado
    \item Puntuar las soluciones propuestas a sus acertijos
    \item Proponer soluciones a cualquier acertijo del sistema
\end{itemize}

Desde el punto de vista del sistema, para conseguir materializar las funciones básicas a llevar a cabo por un usuario y, aún más importante, la gestión de las mismas por un servicio que sea adaptable a cualquier tipo de interfaz, será necesario el desarrollo de una API REST, que actúe como intermediario entre la interfaz y la base de datos.

Aún dentro del sistema, es necesario el almacenamiento de toda esa información, que será usada por el usuario continuamente, en una base de datos intuitiva, actual y sencilla de manejar.


\section{Arquitectura Modelo-Vista-Controlador}

Una vez definido el funcionamiento general de la aplicación, se pueden distinguir 3 bloques o módulos bien diferenciados:

\begin{itemize}
    \item Interfaz o front-end
    \item API REST
    \item Base de datos
\end{itemize}
 
 La arquitectura \textit{MVC} (Modelo Vista Controlador) es la más adecuada para el desarrollo de este proyecto, ya que nos permite hacer una distinción de 3 bloques independientes que colaborarán entre sí para formar nuestra aplicación\cite{mvc2}\cite{mvc3}. Esta arquitectura distingue los bloques\cite{mvc1}:
 
 \begin{itemize}
    \item \textbf{Vista}. En este bloque es donde se representan los datos con los que el sistema operará. En nuestro caso, es nuestra interfaz.
    \item \textbf{Controlador}. Este bloque será el responsable de responder a los distintos eventos en los que se solicite algún tipo de consulta al modelo, o los que se necesite un transporte de información desde el modelo a la interfaz o viceversa. En nuestro caso, será nuestra API.
    \item \textbf{Modelo}. En este bloque se definirá el tipo de datos y su almacenamiento lógico. En nuestro caso, será nuestra base de datos.
\end{itemize}

Cada bloque de nuestra arquitectura se abordará de manera independiente, teniendo muy en cuenta, que éstos, una vez definidos y desarrollados, tendrán que estar conectados para así permitir el flujo de información correspondiente a los eventos por parte de los requisitos del usuario. 

En la imagen \ref{fig::mvc} se pueden contemplar los 3 bloques que forman la arquitectura MVC.

\begin{figure}
    \centerline{\includegraphics[width=11cm]{figuras/mvc.png}}
    \caption{Arquitectua Modelo-Vista-Controlador}
    \label{fig::mvc}
\end{figure}
 
\section{Tecnologías a emplear}

Comenzaremos definiendo las posibles tecnologías que encontramos para desarrollar cada uno de los bloques de nuestra aplicación. Para escoger las tecnologías a emplear, nos basaremos en los requerimientos de la aplicación y nuestra propia intuición como desarrolladores.

\subsection{Tecnologías de desarrollo}

Inicialmente se hará una búsqueda de las distintas tecnologías para el desarrollo del bloque, se compararán y se decidirá cual de ellas es la escogida y el por qué.

\subsubsection{Modelo - Base de Datos}

En el mercado podemos encontrar 2 tipos distintos de bases de datos: relacionales y no relacionales\cite{tipobd}. 

Para el desarrollo de nuestro proyecto, estamos buscando una base de datos que sea intuitiva y sencilla de administrar. Es fundamental encontrar una base de datos que administre eficientemente unos datos de una manera distinta a la visión de "tabla" que nos ofrecen las bases de datos relacionales. Es por ello que se ha escogido una base de datos \textbf{no relacional} para el almacenamiento de los datos de la aplicación.

Dentro de las bases de datos no relacionales encontramos distintos tipos:

\begin{itemize}
    \item Bases de datos documentales
    \item Bases de datos en grafo
    \item Bases de datos clave/valor
    \item Bases de datos multivalor
    \item Bases de datos orientadas a objetos
    \item Bases de datos tabular
    \item Bases de datos de arrays
\end{itemize}

Ante esta abrumadora lista de alternativas, el tutor recomendó que se usaran bases de datos orientadas en grafos. Este tipo no relacional de bases de datos está en auge, y se planea que para un futuro no muy lejano sea el tipo de base de datos más usado\cite{bdnorel1}\cite{bdnorel2}. 

Dentro de las bases de datos basadas en grafos se pueden encontrar dos de las más solicitadas:

\begin{itemize}
    \item neo4j\footnote{https://neo4j.com/}
    \item titan\footnote{http://titan.thinkaurelius.com/}
\end{itemize}

Para nuestra base de datos buscamos la sencillez, la simplicidad y el uso de un único proceso que actúe como servidor e interfaz gráfica de una base de datos intuitiva. La facilidad de instalación y manejo de \textbf{neo4j} la han convertido en la candidata ideal para nuestra aplicación. 

Además de la facilidad a la hora de conectar con cualquier API y escalar conforme el tamaño de la base de datos aumente, hacer copias de seguridad en local y, sobre todo, la aparición de \textit{cypher} como lenguaje de consulta\cite{neovstitan}.

Gracias al inmejorable\textit{online training} y la perfecta descripción de la documentación oficial de neo4j\footnote{https://neo4j.com/graphacademy/online-training/} el aprendizaje de este concepto nuevo de bases de datos y su lenguaje de consulta ha sido un proceso sencillo de llevar a cabo.

El uso de Cypher\footnote{https://neo4j.com/developer/cypher-query-language/} como lenguaje de consulta ha facilitado notablemente la elección de esta base de datos, pues gracias a éste solamente tenemos que tener en cuenta nodos y relaciones que hay entre ellos. Con una serie de órdenes simples podemos gestionar excesivamente rápida e intuitivamente toda la información que necesitemos para el funcionamiento de nuestra aplicación.

\subsubsection{Controlador - API REST}

Para que nuestra API sea sencilla de implementar, usando un lenguaje simple, de alto nivel y con un inicio sencillo a la hora del aprendizaje, libre y con una documentación extensa y infinitud de librerías podemos escoger, podemos distinguir varios lenguajes actuales y de los más utilizados para la creación de servicios rest\cite{apirest1}\cite{apirest2}\cite{apirest3}:

\begin{itemize}
    \item Javascript - Nodejs
    \item Python
    \item Java 
    \item PHP
    \item Ruby
\end{itemize}

Ante estas alternativas, todas son válidas y reúnen la documentación necesaria para desarrollar el proyecto. Es por ello, por lo que para tomar esta decisión me basaré en que en durante estos años en el Grado en Ingeniería Informática de la UGR, el lenguaje que menos he usado en clase, y que es completamente desconocido para mi es \textit{python}. 

Además, tengo de mi lado que es un lenguaje que está convirtiéndose en uno de los lenguajes más utilizados en la plataforma líder en software libre GitHub\footnote{https://octoverse.github.com/} y, uno de los requisitos a tener muy en cuenta en el desarrollo del proyecto es la utilización de tecnologías actuales.

Una vez decidido el lenguaje, existen dos alternativas bien diferenciadas a la hora de crear un servicio web en python:

\begin{itemize}
    \item Flask\footnote{http://flask.pocoo.org/}
    \item Django\footnote{https://www.djangoproject.com/}
\end{itemize}

Una vez estudiadas las características principales de cada alternativa\cite{flaskvsdjango1} y puesto que nuestra aplicación necesitará de un gestor ligero, que contenga solamente métodos que se llamarán desde nuestra interfaz e interactúen con la base de datos, descartamos la opción de usar Django, pues éste es demasiado pesado y tiene añadida la gran dificultad de comprender la estructura con la que funciona, justo lo contrario que Flask, una herramienta simple de entender y que con poco tiempo de estudio se es apto para desarrollar una API que cumpla los requisitos de nuestra aplicación. 

Nuestra API, por lo tanto estará escrita en Python y se usará el framework \textbf{Flask}.

\subsubsection{Vista - Interfaz}

Existen infinidad de frameworks y lenguajes a la hora de desarrollar una interfaz web. Con la idea de querer implementar una interfaz que sea interactiva y ligera, se busca un lenguaje que permita el desarrollo de una web básica, con un liguero toque de red social, ya que se busca en todo momento, que el usuario se enganche a la aplicación. Para ello es fundamental el uso de una interfaz simple.



\subsection{Tecnologías de despliegue}

Inicialmente se hará una búsqueda de las distintas tecnologías para el despliegue del bloque, se compararán y se decidirá cual de ellas es la escogida y el por qué.